\documentclass[12pt, reqno]{amsart}

%%%%%%%%%%%%%%%%%%%%%  MY STUFF %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\makeatletter
%\g@addto@macro{\endabstract}{\@setabstract}
%\makeatother



%\usepackage{epsfig}
\usepackage{graphics, stackrel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{natbib}
\usepackage{enumitem}
%font
%\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{mathpazo}
%\usepackage{tgpagella}

%subfloats / figures
\usepackage{caption}
\usepackage{subcaption}

% For pandas latex tables
\usepackage{booktabs}


\usepackage{fancyvrb}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{mdwlist}

\usepackage[citecolor=blue, colorlinks=true, linkcolor=blue]{hyperref}


% lists
\usepackage{enumitem}
\setlist[enumerate]{itemsep=2pt,topsep=3pt}
\setlist[itemize]{itemsep=2pt,topsep=3pt}
\setlist[enumerate,1]{label=(\alph*)}

\usepackage{mathrsfs}  % caligraphic
%\usepackage{stix} 
\usepackage{bbm}
\usepackage{bm}        % bold symbols


%% page layout
\usepackage[left=1.25in, right=1.25in, top=1.0in, bottom=1.15in, includehead, includefoot]{geometry}

% nice inequalities
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}

% inner product
\providecommand{\inner}[1]{\left\langle{#1}\right\rangle}
\providecommand{\innerp}[1]{\left\langle{#1}\right\rangle_\pi}


\usepackage[ruled, linesnumbered]{algorithm2e}

%extra spacing
\renewcommand{\baselinestretch}{1.25}

%horizonal line
\newcommand{\HRule}{\rule{\linewidth}{0.3mm}}

% skip a line between paragraphs, no indentation
\setlength{\parskip}{1.5ex plus0.5ex minus0.5ex}
\setlength{\parindent}{0pt}

% footnote without a maker (blfootnote)
\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}

\DeclareMathOperator{\Span}{span}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\DeclareMathOperator{\cl}{cl}
%\DeclareMathOperator{\overset{\circ}}{int}
\DeclareMathOperator{\Prob}{Prob}
\DeclareMathOperator{\determinant}{det}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\graph}{graph}

% mics short cuts and symbols
\newcommand{\st}{\ensuremath{\ \mathrm{s.t.}\ }}
\newcommand{\setntn}[2]{ \{ #1 : #2 \} }
\newcommand{\fore}{\therefore \quad}
\newcommand{\preqsd}{\preceq_{sd} }
\newcommand{\toas}{\stackrel {\textrm{ \scriptsize{a.s.} }} {\to} }
\newcommand{\tod}{\stackrel { d } {\to} }
\newcommand{\tou}{\stackrel { u } {\to} }
\newcommand{\toweak}{\stackrel { w } {\to} }
\newcommand{\topr}{\stackrel { p } {\to} }
\newcommand{\disteq}{\stackrel { \mathscr D } {=} }
\newcommand{\eqdist}{\stackrel {\textrm{ \scriptsize{d} }} {=} }
\newcommand{\iidsim}{\stackrel {\textrm{ {\sc iid }}} {\sim} }
\newcommand{\1}{\mathbbm 1}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\dee}{\,{\rm d}}
\newcommand{\og}{{\mathbbm G}}
\newcommand{\ctimes}{\! \times \!}
\newcommand{\sint}{{\textstyle\int}}

\newcommand{\given}{\, | \,}
\newcommand{\A}{\forall}

% d for integrals
\newcommand*\diff{\mathop{}\!\mathrm{d}}
\newcommand*\e{\mathrm{e}}


% Special symbols and shortcuts
\newcommand{\bmeta}{\bm{\eta}}
\newcommand{\bmxi}{\bm{\xi}}

\newcommand{\infot}{\fF_t}

\newcommand{\pspace}{\mathscr{P}(\mathsf{X})}
\newcommand{\cspace}{\mathscr{C}(\mathsf{X})}

%\renewcommand{\times}{\! \times \!}

\newcommand{\aA}{\mathscr A}
\newcommand{\cC}{\mathscr C}
\newcommand{\sS}{\mathcal S}
\newcommand{\bB}{\mathscr B}
\newcommand{\oO}{\mathcal O}
\newcommand{\gG}{\mathcal G}
\newcommand{\hH}{\mathcal H}
\newcommand{\kK}{\mathcal K}
\newcommand{\iI}{\mathcal I}
\newcommand{\eE}{\mathcal E}
\newcommand{\fF}{\mathscr F}
\newcommand{\qQ}{\mathcal Q}
\newcommand{\tT}{\mathcal T}
\newcommand{\xX}{\mathcal X}
\newcommand{\yY}{\mathcal Y}
\newcommand{\rR}{\mathcal R}
\newcommand{\zZ}{\mathcal Z}
\newcommand{\wW}{\mathcal W}
\newcommand{\uU}{\mathcal U}
\newcommand{\lL}{\mathcal L}

\newcommand{\mM}{\mathcal M}
\newcommand{\dD}{\mathcal D}
\newcommand{\pP}{\mathcal P}

\newcommand{\vV}{\mathcal V}

\newcommand{\Bsf}{\mathsf B}
\newcommand{\Hsf}{\mathsf H}
\newcommand{\Vsf}{\mathsf V}

\newcommand{\BB}{\mathbbm B}
\newcommand{\DD}{\mathbbm D}
\newcommand{\RR}{\mathbbm R}
\newcommand{\CC}{\mathbbm C}
\newcommand{\QQ}{\mathbbm Q}
\newcommand{\NN}{\mathbbm N}
\newcommand{\GG}{\mathbbm G}
\newcommand{\UU}{\mathbbm U}
\newcommand{\TT}{\mathbbm T}
\newcommand{\YY}{\mathbbm Y}
\newcommand{\ZZ}{\mathbbm Z}
\newcommand{\HH}{\mathbbm H}
\newcommand{\KK}{\mathbbm K}
\newcommand{\MM}{\mathbbm M}
\newcommand{\PP}{\mathbbm P}
\newcommand{\EE}{\mathbbm E}


\newcommand{\bH}{\mathbf H}
\newcommand{\bT}{\mathbf T}

\newcommand{\var}{\mathbbm V}

\newcommand{\XX}{\mathsf X}
\newcommand{\II}{\mathsf I}
\newcommand{\WW}{\mathsf W}

\renewcommand{\phi}{\varphi}
\renewcommand{\epsilon}{\varepsilon}

\newcommand{\bP}{\mathbf P}
\newcommand{\bQ}{\mathbf Q}
\newcommand{\bE}{\mathbf E}
\newcommand{\bM}{\mathbf M}
\newcommand{\bX}{\mathbf X}
\newcommand{\bY}{\mathbf Y}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}


\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{axiom}{Axiom}[section]
\newtheorem{example}{Example}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{notation}{Notation}[section]
\newtheorem{assumption}{Assumption}[section]
\newtheorem{condition}{Condition}[section]


%\DeclareTextFontCommand{\emph}{\bfseries}

%%%%%%%%%%%%%%%%%% end my preamble %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






\begin{document}


\title{}




\begin{center}
    \LARGE 
    Solving High-Dimensional Asset Pricing Models via Newton--Kantorovich
    Iteration
    \blfootnote{To be added}
 
    \vspace{1em}

    \large
    Chase Coleman\textsuperscript{a}, John Stachurski\textsuperscript{c}, \\ Ole
    Wilms\textsuperscript{d} and Junnan Zhang\textsuperscript{e} \par \bigskip

    \small
    \textsuperscript{a} Research School of Economics, Australian National University \\ 
    \textsuperscript{b} Other affiliations to be added  \\ \bigskip

    \normalsize
    \today
\end{center}


\begin{abstract}
    To be written
    \vspace{1em}

    \noindent
    \textit{JEL Classifications:} D81, G11 \\
    \textit{Keywords:} Asset pricing, wealth-consumption ratio, automatic differentiation
\end{abstract}





\maketitle


%section
\section{Introduction}

As with many sub-fields in economics and finance, researchers working on asset
pricing face the need to handle a growing list of state variables when trying to
match existing theory to the data.  For example, while the seminal paper of
\cite{bansal2004risks} used just two state variables to model the
wealth-consumption ratio, subsequent work has added many features to the
consumption side of this model.  For example, \cite{schorfheide2018identifying}
add preference shocks and an additional stochastic volatility term, leading to
four state variables, while \cite{gomez2021important} use six to handle
expectations of inflation.  

To date, the standard method for handling these kinds of models has been
log-linearization.  However, the underlying models are highly nonlinear and,
moreover, it has been shown that these nonlinearities matter for endogenous
quantities of interest, such as the risk premium (see, e.g.,
\cite{pohl2018higher}).  Hence researchers are seeking better global solution
methods that capture the full impact of underlying nonlinearities.

At the same time, for a model of this type, even a moderate number of state
variables leads to challenging computational problems.  One reason is the
nonlinearities discussed above.  Another is that, in standard calibrations,
discount factors are very close to unity (e.g., 0.998 in
\cite{bansal2004risks}), implying slow convergence of some solution methods.
Moreover, the consumption problem is typically embedded in a larger model with
still more state variables, so fast and accurate solutions are essential.  

In this paper we show how to efficiently approximate global solutions to the
kinds of asset pricing models listed above using Newton--Kantorovich iteration
backed by three features: automatic differentiation, just-in-time compilation
and execution on hardware accelerators such as GPUs. We focus on computing the
wealth-consumption ratio in the asset pricing models we consider, since this
ratio is one of the key elements of the stochastic discount factor used to
recover asset prices.  Typically, when log-linearization is avoided, calculating
the wealth-consumption ratio is the most computationally intensive part of
approximating the stochastic discount factor.

To implement the features listed above, we use JAX. JAX is
scientific library within the Python ecosystem that provides data types,
functions and a compiler for fast linear algebra operations, automatic
differentiation, and automated GPU/TPU support via a just-in-time compiler.
Initially developed in-house at Google,
JAX is typically used for machine learning and AI, since it can scale to large
data operations and automatically differentiate loss functions for gradient
decent. However, JAX is sufficiently low-level that it can be used for many
purposes, including asset pricing.

Using Newton--Kantorovich iteration exploits several key features of JAX. First,
automatic differentiation can be used to efficiently compute the Jacobian of the
operator that defines the wealth-consumption ratio. Second, by switching
Newton's method, rather than a more direct algorithm such as from successive
approximation (i.e., fixed point iteration), we change the problem from many
small iterations to a small number of computationally expensive ones. This
offers greater opportunities for parallelized calculations. Third, JAX permits
inversion of the Jacobian without actually instantiating the full Jacobian
matrix.   This is essential for successfully solving high dimensional problems
asset pricing problems.

We also note that automatic differentiation offers the following important
advantage: compared to numerical derivatives, exact derivatives from automatic
differentiation are more accurate.  This is matters because discount rates are
very low (i.e., discount factors are very close to unity), which makes
convergence is fragile.  


\textcolor{DarkOrchid}{TODO.  Complete once all experiments are done.  Provide
some explanation of what we achieve. Review of related literature.}




\section{Set Up}

In this section we introduce the model and progress to stating the
functional equation for the wealth-consumption ration.  Then we outline the
Newton--Kantorovich iteration scheme.

\subsection{The Wealth-Consumption Ratio}

In discrete-time no-arbitrage environments, the equilibrium price process
$\{P_t\}_{t \geq 0}$ associated with a cash flow $\{G_t\}_{t \geq 1}$ obeys
the fundamental recursion
%
\begin{equation}
    \label{eq:pd}
    P_t
    = \EE_t \, M_{t+1} ( P_{t+1} + G_{t+1} )
    \quad \text{for all } t \geq 0,
\end{equation}
%
where $\{ M_t\}$ is the sequence of single period stochastic discount factors
(see, for example,~\cite{kreps1981arbitrage}, \cite{hansen_richard:1987}
or~\cite{duffie2001dynamic}).  Most of the well-known ``puzzles'' in asset
pricing theory relate to the difficulty of matching \eqref{eq:pd} to the data
across a diverse range of asset classes. Attempts to resolve these puzzles
typically involve relatively sophisticated models for the stochastic discount
factor (SDF) process $\{ M_t\}$.

In the model, the wealth-consumption ratio obeys
%
\begin{equation*}
    \beta^{\theta}
    \EE_t
    \left[
    \left( \frac{\lambda_{t+1}}{\lambda_t} \right)^\theta
        \left( \frac{C_{t+1}}{C_t} \right)^{1-\gamma}
        \left( \frac{w(X_{t+1})}{w(X_t)-1} \right)^\theta
    \right] = 1,
\end{equation*}
%
where $\{ X_t \}_{t \geq 0}$ is a stationary time-homogeneous Markov process on
$\XX \subset \RR^d$.
Rearranging the previous expression gives
%
\begin{align*}
    (w(X_t)-1)^\theta
    & = \beta^{\theta}
    \EE_t
    \left[
    \left( \frac{\lambda_{t+1}}{\lambda_t} \right)^\theta
        \left( \frac{C_{t+1}}{C_t} \right)^{1-\gamma}
        w(X_{t+1})^\theta
    \right]
    \\
    & = \beta^{\theta}
    \EE_t
    \left[
        \exp
        \left\{ 
            \theta g_{\lambda, t+1} + (1-\gamma) g_{c, t+1}
        \right\}
        w(X_{t+1})^\theta
    \right],
\end{align*}
%
where
%
\begin{equation}
    \label{eq:kappa}
    g_{c, t+1}
    := \ln \frac{C_{t+1}}{C_t}
    \quad \text{and} \quad
    g_{\lambda, t+1}
    := \ln \frac{\lambda_{t+1}}{\lambda_t}.
\end{equation}
%

Let $\HH$ be the linear operator defined by
%
\begin{equation}\label{eq:defk}
    (\HH f)(x) = \EE_x 
        \, f(X_{t+1})  \,
        \exp
        \left\{ 
            \theta g_{\lambda, t+1} + (1-\gamma) g_{c, t+1}
        \right\}
\end{equation}
%
at each $x \in \XX$,  where $\EE_x$ conditions on $X_t = x$.  With this notation
we can write the equation for the wealth-consumption ratio as
    $(w(x)-1)^\theta
    = \beta^{\theta}
    \left[
        (\HH w)(x)^\theta
    \right]$.
Rearranging once more gives the functional equation
%
\begin{equation}\label{eq:fe}
    w = 1 + \beta ( \HH w^\theta )^{1/\theta}.
\end{equation}
%
\cite{stachurski2022unique} show that, under mild conditions, \eqref{eq:fe} has
a unique solution $w^*$ in the space of continuous everywhere positive functions
on $\XX$ if and only if $r(\HH)^{1/\theta} < 1$, where $r(\HH)$ is the spectral radius
of the operator $\HH$.  This condition is satisfied in the models we consider.



\subsection{Solution Methods}

A function $w$ solves \eqref{eq:fe} if and only if $w$ is a fixed point
of the (nonlinear) operator $\TT$ defined by 
%
\begin{equation}\label{eq:wcop}
    \TT w = 1 + \beta \,  (\HH w^\theta)^{1/\theta}.
\end{equation}
%
\cite{stachurski2022unique} also show that, under the same spectral radius condition
$r(\HH)^{1/\theta} < 1$ and with $w^*$ denoting the unique fixed point of $\TT$,
the convergence $\lim_{k \to \infty} \| \TT^k w - w^*\|_\infty = 0$ holds for any
strictly positive initial condition $w$, where $\| \cdot \|_\infty$ is the
supremum norm. Hence successive approximation (i.e., iteration with $\TT$)
provides one reliable and globally convergent method for computing $w^*$.

However, successive approximation is typically slow, since (a) in these models, the
discount factor is very close to unity, and (b) successive approximation is
inherently sequential and offers relatively limited opportunities for
parallelization.  For this reason we focus instead on Newton--Kantorovich
iteration,  

Background on Newton's algorithm in $\RR^N$.  Let $f$ be a smooth map from
$\RR^N$ to itself.  We want to find the $x \in \RR^N$ that solves $f(x)=x$.
Ordinary successive approximation uses
%
\begin{equation}
    x_{k+1} = f(x_k)
\end{equation}
%
Newton's method first sets $g(x) = f(x) -x$, so that we are seeking a root $x$
satisfying $g(x)=0$, and then iterates on
%
\begin{equation}
    x_{k+1} = g(x_k) + J(x_k)^{-1} g(x_k)
\end{equation}
%
where $J(x)$ is the Jacobian of $g$ at $x$.



\section{Applications}

\subsection{Example: The SSY Case}

To implement the Koopmans operator $\TT$, we need to specify the linear operator
$\HH$.  Here we specify $\HH$ for the 
the long run risk model of \cite{schorfheide2018identifying}.  

In this model, the state process takes the form 
%
\begin{equation}\label{eq:state}
    X_t := (h_{\lambda, t}, h_{c, t}, h_{z, t}, z_t)  
\end{equation}
%
where
\begin{equation*}
    z_{t+1} = \rho \, z_t + (1 - \rho^2)^{1/2} \, \sigma_{z, t} \, \epsilon_{t+1}
\end{equation*}
%
and
%
\begin{equation*}
    \sigma_{i,t} = \phi_i \, \bar{\sigma} \, \exp(h_{i,t}),
    \qquad
    h_{i, t+1} = \rho_i \, h_{i,t} + s_{i} \, \eta_{i, t+1},
    \qquad
    i \in \{z, c, \lambda\}.
\end{equation*}

The consumption and preference shock growth rates are
%
\begin{equation}\label{eq:ssygc}
    g_{c, t+1}
    = \mu_c + z_t + \sigma_{c, t} \, \xi_{c, t+1} 
    \quad \text{and} \quad
    g_{\lambda, t+1} = h_{\lambda, t+1}.
\end{equation}
%
The innovations are all independent and standard normal.  

In this setting, the operator $\HH$ takes the form
%
\begin{equation*}
    (\HH f)(x)
    = \EE_x
        \, f(X_{t+1}) 
        \exp \left\{
            \theta h_{\lambda, t+1}
            + (1-\gamma)(\mu_c + z_t + \sigma_{c, t} \xi_{c, t+1})
        \right\}.
\end{equation*}
%
We can reduce dimensionality in the conditional expectation by integrating out
the independent innovation $\xi_{c, t+1}$, which leads to 
%
\begin{equation}
    (\HH f)(x)
    = \exp \left\{
            (1-\gamma)(\mu_c + z)
            + \frac{1}{2} (1-\gamma)^2 \sigma_c^2 
        \right\}
        \EE_x \, f(X_{t+1}) 
        \exp \left\{
            \theta h_{\lambda, t+1}
        \right\},
\end{equation}
%
where the conditioning is on $X_t = x$ as given in \eqref{eq:state}.
We can write the operator more explicitly as
%
\begin{equation}
    (\HH f)(x)
    = \kappa(z, h_c)
        \EE_x \, f(X_{t+1}) 
        \exp \left\{
            \theta h_{\lambda, t+1}
        \right\},
\end{equation}
%
where
%
\begin{equation}\label{eq:kap}
    \kappa(z, h_c) 
     := \exp \left\{
            (1-\gamma)(\mu_c + z)
            + \frac{1}{2} (1-\gamma)^2 
            [\phi_c \, \bar{\sigma} \, \exp(h_c)]^2 
        \right\}.
\end{equation}
%
The baseline parameter values can be found in the code repository.



\subsection{Example: The GCY Case}

In this section, we analyze the stability properties of the model of
\cite{GomezYaron2020}. The authors add inflation dynamics to a long-run risk
model similar to the one of \cite{schorfheide2018identifying}. In particular,
they assume that the expected inflation rate $z_{\pi,t}$ affects the mean growth
rate of consumption:
%
\begin{equation}\label{eq:gcycg}
	g_{c, t+1} 
	= \ln \left( \frac{C_{t+1}}{C_t} \right)    
	= \mu_c + z_t + \sigma_{c, t} \, \xi_{c, t+1},
\end{equation}
%
where
%
\begin{align*}
	z_{t+1} 
	&= \rho \, z_t + \rho_{\pi} \, z_{\pi,t}+ 
	\sigma_{z, t} \, \eta_{t+1}\\
	z_{\pi,t+1} 
	&= \rho_{\pi \pi} \, z_{\pi,t} + \sigma_{z \pi, t} \, \eta_{\pi,t+1}
\end{align*}
%
and
%
\begin{equation}
	\sigma_{i,t} 
	= \phi_i \, \bar{\sigma} \, \exp(h_{i, t})
\end{equation}
%
with
%
\begin{equation*}
	h_{i, t+1}
	= \rho_i \, h_{i,t} + s_i \, \eta_{i, t+1}
	\quad \text{for } i \in \{z, c, z\pi \}.
\end{equation*}
%
Note that also the expected inflation rate $z_{\pi,t}$ has stochastic volatility
$\sigma_{z\pi,t}$. As in the model of \cite{schorfheide2018identifying}, the
process $\{\lambda_t\}$ follows \eqref{eq:ssygc} and all shocks are
\textsc{iid} and standard normal. Hence, the state vector $x$ contains 6 states
and is given by
%
\begin{equation*}
    x = (z, z_\pi, h_z, h_c, h_{z\pi}, h_\lambda) \in \XX := \RR^6. 
\end{equation*}
%
We can apply the same conditioning as in the model of
\cite{schorfheide2018identifying} and we need to compute $\sS_c$ numerically
again. The baseline parameter values can be found in the code repository.



\section{Solution Method}


\subsection{Discretization}

For computation, the state process is distcretized onto a state space $S =
\{x_1, \ldots, x_N\}$ of size $N \in \NN$ and the operator $\HH$ is
represented by a matrix $\bH$, with 
%
\begin{equation}\label{eq:defkb}
    \bH(n, n') = \sum_{n'=1}^N 
        \,
        \exp
        \left\{ 
            \theta g_\lambda(x_n, x_{n'}, \xi) 
            + (1-\gamma) g_c(x_n, x_{n'}, \xi)
        \right\}
    \bP(n, n'),
\end{equation}
%
where $\bP$ is an $N \times N$ matrix with  $\bP(n, n')$ representing the
probability that the discretized state process transitions from state $x_n$ to
state $x_{n'}$ in one unit of time.

The discretization of $\TT$ is written as $\bT$ and the problem is to find the
fixed point of 
%
\begin{equation}\label{eq:wcopd}
    (\bT w) = 1 + \beta \,  (\bH w^\theta)^{1/\theta}
\end{equation}
%
in the set of strictly positive vectors in $\RR^N$.


\section{Conclusion}

TODO describe outcomes.

One research avenue we have not explored here is that one can potentially
differentiate the fixed point with respect to the parameters using automatic
differentiation. These gradients are helpful to study how the wealth-consumption
ratio and stochastic discount factor respond to shifts in underlying parameters,
as well as providing Jacobians for gradient decent in estimation problems.
We leave these topics for future work.



\bibliographystyle{ecta}

\bibliography{localbib}


\end{document}
